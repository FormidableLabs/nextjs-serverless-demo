# CloudFormation output name: `sls-${SERVICE_NAME}-${STAGE}`
service: sls-${self:custom.service}

package:
  individually: true

custom:
  service: ${env:SERVICE_NAME}
  region: ${opt:region, env:AWS_REGION}
  stage: ${opt:stage, env:STAGE}
  jetpack:
    preInclude:
      - "!**" # Start with no files at all.
    trace:
      ignores:
        # Provided on Lambda
        - "aws-sdk"

        # Stuff Next.js trace mode ignores.
        # https://github.com/vercel/next.js/blob/ab40370ea5b69aa4dd601907eb85d25da1140b6b/packages/next/build/index.ts#L1257-L1280
        # https://unpkg.com/browse/next@12.1.0/dist/build/index.js (L765-L777)
        - "next/dist/compiled/webpack/bundle4"
        - "next/dist/compiled/webpack/bundle5"
        - "webpack5"

        # Ignore real deps in Next.js that we shouldn't need at runtime.
        - "caniuse-lite"
        - "postcss"

      allowMissing:
        "node-fetch":
          - "encoding"
        "next":
          - "critters"  # for CSS optimization
          - "pnpapi"    # for PnP usage
          - "fibers"    # Part of sass-loader

      dynamic:
        resolutions:
          # Sources
          # -------
          # Our servers do lazy requires of pages.
          "./server/blog.js": []
          "./server/root.js": []

          # Built
          # -----
          # Webpack chunk loading
          # .next/server/webpack-api-runtime.js [131:27]: require("./chunks/" + __webpack_require__.u(chunkId))
          # .next/server/webpack-runtime.js [143:27]: require("./chunks/" + __webpack_require__.u(chunkId))
          "./.next/server/webpack-api-runtime.js": []
          "./.next/server/webpack-runtime.js": []

          # Dependencies
          # ------------
          # express/lib/view.js [81:13]: require(mod)
          "express/lib/view.js": []

          # Optional optimizer.
          # next/dist/compiled/@ampproject/toolbox-optimizer/index.js [1:18400]: require.resolve(t)
          "next/dist/compiled/@ampproject/toolbox-optimizer/index.js": []

          # Webpack plugin tool.
          # next/dist/compiled/cssnano-simple/index.js [1:22560]: require.resolve(name,{paths:["."]})
          # next/dist/compiled/cssnano-simple/index.js [1:22989]: require(__nccwpck_require2_(8440).resolve(path.join(v,"browserslist-stats.json"),{paths:["."]}))
          # next/dist/compiled/cssnano-simple/index.js [1:24041]: require("caniuse-lite/data/regions/"+_+".js")
          # next/dist/compiled/cssnano-simple/index.js [1:24281]: require("caniuse-lite/data/features/"+v+".js")
          "next/dist/compiled/cssnano-simple/index.js": []

          # Webpack related.
          # next/dist/compiled/jest-worker/index.js [1:8267]: require.resolve(e)
          # next/dist/compiled/jest-worker/index.js [1:22446]: require(e)
          "next/dist/compiled/jest-worker/index.js": []

          # Image optimization.
          # next/dist/server/image-optimizer.js [50:12]: require(process.env.NEXT_SHARP_PATH || 'sharp')
          "next/dist/server/image-optimizer.js": []

          # Server components.
          # next/dist/server/load-components.js [12:57]: require(`next/dist/pages/_document` + (hasConcurrentFeatures ? '-concurrent' : ''))
          # next/dist/server/load-components.js [22:23]: require((0, _path).join(distDir, `fallback-${_constants.BUILD_MANIFEST}`))
          # next/dist/server/load-components.js [61:8]: require((0, _path).join(distDir, _constants.BUILD_MANIFEST))
          # next/dist/server/load-components.js [62:8]: require((0, _path).join(distDir, _constants.REACT_LOADABLE_MANIFEST))
          "next/dist/server/load-components.js": [
            "next/dist/pages/_document",
            "next/dist/pages/_document-concurrent"
            # `path.join(distDir, **)` paths are already manually traced and included.
          ]

          # Runtime build directory imports.
          # node_modules/next/dist/server/next-server.js [118:15]: require(pagesManifestPath)
          # node_modules/next/dist/server/next-server.js [373:33]: require(builtPagePath)
          # node_modules/next/dist/server/next-server.js [458:15]: require((0, _path).join(this.distDir, 'server', _constants.MIDDLEWARE_FLIGHT_MANIFEST + '.json'))
          # node_modules/next/dist/server/next-server.js [601:19]: require(middlewareManifestPath)
          # node_modules/next/dist/server/next-server.js [894:25]: require((0, _path).join(this.distDir, _constants.PRERENDER_MANIFEST))
          # node_modules/next/dist/server/next-server.js [898:15]: require((0, _path).join(this.distDir, _constants.ROUTES_MANIFEST))
          "next/dist/server/next-server.js": []
          # node_modules/next/dist/server/require.js [22:26]: require((0, _path).join(serverBuildPath, _constants.PAGES_MANIFEST))
          # node_modules/next/dist/server/require.js [48:11]: require(pagePath)
          # node_modules/next/dist/server/require.js [52:25]: require((0, _path).join(serverBuildPath, _constants.FONT_MANIFEST))
          # node_modules/next/dist/server/require.js [57:31]: require((0, _path).join(serverBuildPath, _constants.MIDDLEWARE_MANIFEST))
          "next/dist/server/require.js": []

          # Allows arbitrary importing of code and execution in a VM. All bets are off :P
          # node_modules/next/dist/server/web/sandbox/require.js [21:25]: require.resolve(specifier, {
          #     paths: [
          #         (0, _path).dirname(referrer)
          #     ]
          # })
          "next/dist/server/web/sandbox/require.js": []

plugins:
  - serverless-jetpack
  - serverless-offline

provider:
  name: aws

  # Required: import the default role that terraform-aws-serverless generates.
  role:
    Fn::ImportValue: tf-${self:custom.service}-${self:custom.stage}-LambdaExecutionRoleArn

  # Lambda configuration
  runtime: nodejs12.x
  timeout: 30 # seconds (`300` max)
  memorySize: 1024 # MB value (`1024` default)

  # Deployment / environment configuration
  region: ${self:custom.region}
  stage: ${self:custom.stage}
  environment:
    STAGE: ${self:custom.stage}
    SERVICE_NAME: ${self:custom.service}
    NODE_ENV: production

  # AWS Resource Tags: Match terraform module
  stackTags: # For CF stack
    Stage: ${self:custom.stage}
    Service: ${self:custom.service}
  tags: # For resources
    Stage: ${self:custom.stage}
    Service: ${self:custom.service}

  # TODO(STATIC): Allows serving of binary media. Shouldn't use this for real.
  apiGateway:
    binaryMediaTypes:
      - "*/*"

functions:
  # SCENARIO - base: The simplest, vanilla Serverless app.
  blog:
    handler: server/blog.handler
    environment:
      BASE_PATH: /blog
    events: # Use a generic proxy to allow Express app to route.
      - http: ANY /blog
      - http: 'ANY /blog/{proxy+}'
    jetpack:
      trace:
        include:
          # Next.js config/generated files: gather dependencies
          - "next.config.js"
          - ".next/server/**/*.js"
    package:
      include:
        # Raw data for posts is read from disk outside `.next` build directory.
        - "src/posts/**/*.md"
        # Needed built Next.js assets and info. (Some of these are also traced).
        - ".next/BUILD_ID"
        - ".next/*.json"
        - ".next/server/**"
        # Ignore all NFT files.
        - "!**/*.nft.json"
        # TODO(STATIC): Should be served outside Lambda in real production.
        - ".next/static/**"

  # TODO(STATIC): Simple static server for root assets.
  root:
    handler: server/root.handler
    environment:
      BASE_PATH: /
    events: # Use a generic proxy to allow Express app to route.
      - http: ANY /
      - http: 'ANY /{proxy+}'
    package:
      include:
        # TODO(STATIC): Should be served outside Lambda in real production.
        - "public/**"
